<!DOCTYPE html>
<html lang="zh-CN" class="light">
<head>
  <meta charset="utf-8">
  
  <title>
    
    Bean在Spring中是如何被创建的？
    
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="/logo.png" type="image/svg+xml" />

  <!-- lightgallery查看图片支持 -->
  
<link rel="stylesheet" href="/js/lightgallery/lightgallery.css">

  
<script src="/js/lightgallery/lightgallery.min.js"></script>

  
<script src="/js/lightgallery/lg-zoom.min.js"></script>

  
<script src="/js/lightgallery/lg-fullscreen.min.js"></script>

  
<script src="/js/lightgallery/lg-thumbnail.min.js"></script>

  
  <!-- 活动图支持 -->
  
<script src="/js/echart/echarts-4.8.0.min.js"></script>


  <!-- 思维导图支持 -->
  
<script src="/js/markmap/d3@6.js"></script>

  
<script src="/js/markmap/markmap-view@0.2.7.js"></script>

  
<link rel="stylesheet" href="/js/markmap/katex.min.css">

  
<link rel="stylesheet" href="/js/markmap/custom-markmap.css">

  
  <!-- 字体支持 -->
  
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Mono&family=Noto+Sans+SC:wght@300&display=swap.css">

  
<link rel="stylesheet" href="/iconfont/iconfont.css">

  
  <!-- 代码高亮支持 -->
  
<script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/prism/1.17.1/prism.min.js"></script>

  
<script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js"></script>

  
<script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/prism/1.17.1/plugins/line-numbers/prism-line-numbers.min.js"></script>

  
<link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/prism/1.17.1/plugins/line-numbers/prism-line-numbers.min.css">

  
<link rel="stylesheet" href="/css/prism/material-light.css">

  
<link rel="stylesheet" href="/css/prism/material-dark.css">


  <!-- 自定义样式 -->
  
<link rel="stylesheet" href="/css/style.css">


<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div class="layout-container">
    <header>
  <a href="/"><img class="header-logo" src="/logo.png"/></a>
  <h3>xuMengqi&#39;s Blog</h3>
  <ul class="header-nav">
    <li class="header-nav-child">
      <a href="/">首页</a>
    </li>
    <li class="header-nav-child">
      <a href="/categories">分类</a>
    </li>
    <li class="header-nav-child">
      <a href="/tags">标签</a>
    </li>
    <li class="header-nav-child">
      <a href="/about">关于我</a>
    </li>
    <li class="header-nav-child">
      <img class="header-theme-switcher" onclick="switchTheme()"  src="/img/dark-mode.svg"/>
    </li>
  </ul>
  <img class="header-to-top" onclick="scrollToTop()" src="/img/top.svg"/>
<script>
  function scrollToTop() {
    document.body.scrollTop = 0; // 对Safari
    document.documentElement.scrollTop = 0; // 对Chrome, Firefox, IE 和 Opera
  }
  
  function setThemeMode(mode) {
    localStorage.setItem('theme-mode', mode)
  }

  function getThemeMode() {
    return localStorage.getItem('theme-mode')
  }

  function switchTheme() {
    let themeMode = getThemeMode()
    if (themeMode === 'light') {
      document.documentElement.className = 'dark'
      document.getElementsByClassName('header-theme-switcher')[0].src = "/img/light-mode.svg"
      setThemeMode('dark')
    } else {
      document.documentElement.className = 'light'
      document.getElementsByClassName('header-theme-switcher')[0].src = "/img/dark-mode.svg"
      setThemeMode('light')
    }
  }
  
  // 开启主题
  if (getThemeMode() === null) {
	  switchTheme()
  }
  if (getThemeMode() === 'dark') {
    setThemeMode('light')
    switchTheme()
  }
  

  
  var prevScrollpos = window.pageYOffset;
  /* Get the header element and it's position */
  var headerDiv = document.getElementsByTagName("header")[0];
  var headerBottom = headerDiv.offsetTop + headerDiv.offsetHeight;
  window.onscroll = function() {
    var currentScrollPos = window.pageYOffset;
    /* if scrolling down, let it scroll out of view as normal */
    if (prevScrollpos <= currentScrollPos ){
        headerDiv.style.top ="-6rem";
    }
    /* otherwise if we're scrolling up, fix the nav to the top */
    else{  
        headerDiv.style.top = "0";
    }
    prevScrollpos = currentScrollPos;
  }
</script>
</header>
    <main class="main-post">
  <div class="toc-container">
  <div class="toc-toggle">
    <i id="toc-b-icon" class="iconfont icon-liebiao-01" onclick="toggleShow()"></i>
  </div>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">1. 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">2. 如果让你设计，你会如何设计？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">3. Spring是如何设计的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractBeanFactory-doGetBean-%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.1. AbstractBeanFactory#doGetBean 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%BC%A0%E5%85%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">3.1.1. 转换传入的名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8D%95%E4%BE%8B%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96Bean"><span class="toc-text">3.1.2. 从单例缓存中获取Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%88%B6BeanFactory%E4%B8%AD%E8%8E%B7%E5%8F%96Bean"><span class="toc-text">3.1.3. 从父BeanFactory中获取Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6BeanDefinition"><span class="toc-text">3.1.4. 合并BeanDefinition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="toc-text">3.1.5. 检查依赖项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9D%A5%E5%88%9B%E5%BB%BABean"><span class="toc-text">3.1.6. 根据作用域来创建Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8EBean%E5%AE%9E%E4%BE%8B%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.1.7. 从Bean实例中获取对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8DBean%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1.8. 适配Bean实例的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractAutowireCapableBeanFactory-createBean-%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.2. AbstractAutowireCapableBeanFactory#createBean 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90Bean%E7%9A%84Class"><span class="toc-text">3.2.1. 解析Bean的Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">3.2.2. 准备方法重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%89%8D%E8%A7%A3%E6%9E%90Bean"><span class="toc-text">3.2.3. 实例化前解析Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABean%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.2.4. 创建Bean实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractAutowireCapableBeanFactory-doCreateBean-%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.3. AbstractAutowireCapableBeanFactory#doCreateBean 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96Bean"><span class="toc-text">3.3.1. 实例化Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6BeanDefinition%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-text">3.3.2. 合并BeanDefinition后置处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEBean%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">3.3.3. 设置Bean的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96Bean"><span class="toc-text">3.3.4. 初始化Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CBean%E7%9A%84%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"><span class="toc-text">3.3.5. 注册Bean的销毁回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81Bean"><span class="toc-text">3.3.6. 销毁Bean</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">3.4. Bean的创建的流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-text">4. 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BA%A7Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">4.1. 如何自定义一个线程级Bean的作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%9E%8BBean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8D%95%E4%BE%8BBean%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%9E%8B%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">4.2. 如何解决原型Bean依赖注入单例Bean导致原型失效的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="toc-text">4.3. 三级缓存是如何解决循环依赖的？</span></a></li></ol></li></ol>
</div>

<script>
  var show = false
  function toggleShow() {
    if (show) {
      document.getElementsByClassName('toc')[0].className = 'toc'
      document.getElementById('toc-b-icon').className = 'iconfont icon-liebiao-01'
    } else {
      document.getElementsByClassName('toc')[0].className = 'toc show'
      document.getElementById('toc-b-icon').className = 'iconfont icon-quxiao-01'
    }
    show = !show
  }
  document.getElementsByClassName('toc')[0].onclick = toggleShow
</script>

  <div class="article-header">
    <div class="article-tags">
      
        <a class="article-tags-version" href="/categories/SpringFramework">> SpringFramework</a>
      
      
    </div>
    <div class="article-title">
      <h1>Bean在Spring中是如何被创建的？</h1>
    </div>
    <div class="article-details">
      <div class="article-post-date">
        <span>作者：徐梦旗，发布于：2023-07-16 00:04，字数：3.8k，预计阅读：15分钟</span>
	    </div>
    </div>
  </div>
  <div class="article">
  
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" type="text/css" href><div class=".article-gallery">
<div class="markmap-container" style="height:400px">
  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Bean的创建&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;AbstractBeanFactory#doGetBean&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;转换传入的名称&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;从单例缓存中获取Bean&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;从父BeanFactory中获取Bean&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;合并BeanDefinition&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;检查依赖项&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;根据作用域来创建Bean&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;从Bean实例中获取对象&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;适配Bean实例的类型&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;AbstractAutowireCapableBeanFactory#createBean&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;解析Bean的Class&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;准备方法重写&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;实例化前解析Bean&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;创建Bean实例&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;AbstractAutowireCapableBeanFactory#doCreateBean&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;实例化Bean&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;合并BeanDefinition后置处理&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;设置Bean的属性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;初始化Bean&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;注册Bean的销毁回调&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;销毁Bean&quot;}]}]}"/>
</div>


<h2 id="背景">1. 背景</h2><p>我们使用Spring是为了让Spring帮我们管理Bean（也就是依赖）。如果只是简单地使用Spring创建的Bean，便无需了解Spring内部发生了什么；但如果想要得到更定制化的Bean，便需要对Spring创建Bean的过程进行扩展，也就需要了解Bean在Spring中是如何被创建的。</p>
<blockquote>
<p>Bean，Bean定义，Bean实例有什么区别？</p>
<ul>
<li>Bean是可重复使用的组件，也是对依赖的描述；</li>
<li>Bean定义则用来记录Bean的信息；</li>
<li>Bean实例是通过Bean定义创建的实例，也就是实际使用的依赖。</li>
</ul>
<p>获取一个Bean和创建一个Bean有什么区别？</p>
<ul>
<li>对于单例Bean，在首次获取Bean的时候会创建Bean，后续获取Bean会从缓存中获取；</li>
<li>对于原型Bean，在每次获取Bean的时候都会创建一个新的Bean。</li>
</ul>
</blockquote>
<h2 id="如果让你设计，你会如何设计？">2. 如果让你设计，你会如何设计？</h2><p>简单地说，创建Bean无非就是根据Bean定义创建一个Bean实例。下面让我们看看创建一个Bean需要哪些步骤：</p>
<ol>
<li>实例化Bean：根据Bean定义获取到<code>class</code>类型，并通过反射的方式创建一个Bean实例；</li>
<li>设置属性值：根据Bean定义获取到属性值，并通过反射的方式为Bean实例设置属性值；</li>
<li>执行初始化方法：根据Bean定义获取到初始化方法，并通过反射的方式执行初始化方法。</li>
</ol>
<a href="/assert/puml/caf9d6a12651aa4b16c2e78f24993c9d2a6def8a171608851dc82e900f737ad1.svg" class="gallery-item"><img src="/assert/puml/caf9d6a12651aa4b16c2e78f24993c9d2a6def8a171608851dc82e900f737ad1.svg"></a>

<h2 id="Spring是如何设计的？">3. Spring是如何设计的？</h2><p>同我们上面的设计类似，不过Spring为了满足更多更复杂的场景，其提供了更多的扩展点，如为依赖注入，AOP，<code>Aware</code>接口等提供支持。Bean的创建由<code>BeanFactory#getBean</code>方法触发，会依次执行以下方法：</p>
<ol>
<li><code>AbstractBeanFactory#doGetBean</code></li>
<li><code>AbstractAutowireCapableBeanFactory#createBean</code></li>
<li><code>AbstractAutowireCapableBeanFactory#doCreateBean</code></li>
</ol>
<h3 id="AbstractBeanFactory-doGetBean-详解">3.1. AbstractBeanFactory#doGetBean 详解</h3><a href="/assert/puml/4a641c7307a1b18cdf9b5bd456227abd4b4acf3c59dc307664d33096bcdb8238.svg" class="gallery-item"><img src="/assert/puml/4a641c7307a1b18cdf9b5bd456227abd4b4acf3c59dc307664d33096bcdb8238.svg"></a>
<h4 id="转换传入的名称">3.1.1. 转换传入的名称</h4><p><code>DefaultListableBeanFactory</code>维护了一个Bean名称与<code>BeanDefinition</code>的映射（也就是<code>beanDefinitionMap</code>），我们通过Bean名称可以去该映射中获取到<code>BeanDefinition</code>，用于后续的创建Bean的操作。那为什么还需要转换传入的名称呢？其实传入的名称不一定是映射中的Bean名称，主要有以下两种场景：</p>
<ol>
<li>当获取<code>FactoryBean</code>类型的Bean时。假如有一个Bean名称为<code>factoryBean</code>的<code>FactoryBean</code>：</li>
</ol>
<ul>
<li>当传入的名称为<code>factoryBean</code>时，会返回<code>FactoryBean</code>工厂创建的Bean；</li>
<li>当传入的名称为<code>&amp;factoryBean</code>时，会返回<code>FactoryBean</code>工厂。</li>
</ul>
<ol start="2">
<li>当传入的名称是别名时，需要根据别名找到实际的Bean名称。</li>
</ol>
<blockquote>
<p>对应源码所在位置：<code>AbstractBeanFactory#transformedBeanName</code>。</p>
</blockquote>
<h4 id="从单例缓存中获取Bean">3.1.2. 从单例缓存中获取Bean</h4><p>单例Bean首次获取并创建后会被添加到单例缓存中去，后续再次获取该Bean时，会直接从缓存中获取。这也是为什么单例Bean每次通过<code>getBean</code>获取时都会返回同一个对象的原因。</p>
<blockquote>
<p>对应源码所在位置：<code>DefaultSingletonBeanRegistry#getSingleton</code>。</p>
</blockquote>
<h4 id="从父BeanFactory中获取Bean">3.1.3. 从父BeanFactory中获取Bean</h4><p>如果当前<code>BeanFactory</code>中不包含Bean名称对应的<code>BeanDefinition</code>，且当前<code>BeanFactory</code>有父<code>BeanFactory</code>，则委派给父<code>BeanFactory</code>进行Bean的获取。</p>
<h4 id="合并BeanDefinition">3.1.4. 合并BeanDefinition</h4><p>如果Bean名称对应的<code>BeanDefinition</code>配置了父<code>BeanDefinition</code>，则需要进行<code>BeanDefinition</code>的合并。由子<code>BeanDefinition</code>的信息覆盖父<code>BeanDefinition</code>中的信息。这也是XML配置中的<code>bean</code>标签的<code>parent</code>属性的原理。</p>
<blockquote>
<p>对应源码所在位置：<code>AbstractBeanFactory#getMergedLocalBeanDefinition</code>。</p>
</blockquote>
<h4 id="检查依赖项">3.1.5. 检查依赖项</h4><p>如果Bean名称对应的<code>BeanDefinition</code>配置了<code>dependsOn</code>依赖项，则在创建当前Bean之前，需要确保该Bean所依赖的Bean都已经被初始化。这也是XML配置中<code>bean</code>标签的<code>depends-on</code>属性和注解配置中<code>@DependsOn</code>的原理。</p>
<h4 id="根据作用域来创建Bean">3.1.6. 根据作用域来创建Bean</h4><ol>
<li><p>创建单例Bean<br>如果Bean名称对应的<code>BeanDefinition</code>是单例的，则调用<code>DefaultSingletonBeanRegistry#getSingleton</code>包装过的<code>AbstractAutowireCapableBeanFactory#createBean</code>创建Bean。Bean在被创建后会加入到单例缓存中，这也是为什么单例Bean每次获取时都会返回相同对象的原因。</p>
</li>
<li><p>创建原型Bean<br>如果Bean名称对应的<code>BeanDefinition</code>是原型的，则调用<code>AbstractAutowireCapableBeanFactory#createBean</code>创建Bean。相比于单例Bean，Bean在创建后并不会加入到单例缓存中，这也是为什么原型Bean每次获取时都会返回不同对象的原因。</p>
</li>
<li><p>创建自定义作用域Bean<br>如果Bean名称对应的<code>BeanDefinition</code>是自定义的，则调用自定义作用域<code>Scope#get</code>包装过的<code>AbstractAutowireCapableBeanFactory#createBean</code>创建Bean。这也是<code>session</code>和<code>request</code>等自定义作用域工作的原理。</p>
</li>
</ol>
<blockquote>
<p>对应源码所在位置：<code>DefaultSingletonBeanRegistry#getSingleton</code>。</p>
</blockquote>
<h4 id="从Bean实例中获取对象">3.1.7. 从Bean实例中获取对象</h4><p>如果传入的名称不是以<code>&amp;</code>开头，并且Bean的实例是<code>FactoryBean</code>时，则需要调用<code>FactoryBean#getObject</code>方法得到工厂创建的Bean。这也是为什么使用Bean名称获取<code>FactoryBean</code>类型的Bean时，会返回<code>FactoryBean</code>工厂创建的Bean的原因。</p>
<blockquote>
<p>对应源码所在位置：<code>AbstractBeanFactory#getObjectForBeanInstance</code>。</p>
</blockquote>
<h4 id="适配Bean实例的类型">3.1.8. 适配Bean实例的类型</h4><p>如果创建的Bean不是所需的<code>Class</code>类型，则需要进行类型转换，然后再返回。</p>
<blockquote>
<p>对应源码所在位置：<code>AbstractBeanFactory#adaptBeanInstance</code>。</p>
</blockquote>
<h3 id="AbstractAutowireCapableBeanFactory-createBean-详解">3.2. AbstractAutowireCapableBeanFactory#createBean 详解</h3><a href="/assert/puml/2f1edf16c7e6b68b2fe73e838d04f017f0e548a2d768bd8f8d9d0e0f766ba888.svg" class="gallery-item"><img src="/assert/puml/2f1edf16c7e6b68b2fe73e838d04f017f0e548a2d768bd8f8d9d0e0f766ba888.svg"></a>

<h4 id="解析Bean的Class">3.2.1. 解析Bean的Class</h4><p>如果Bean名称对应的<code>BeanDefinition</code>中的<code>Class</code>还未被解析，则需要将<code>BeanDefinition</code>中的<code>beanClassName</code>解析为具体的<code>Class</code>。这也是XML配置中<code>bean</code>标签的<code>class</code>属性的原理。</p>
<blockquote>
<p>对应源码所在位置：<code>AbstractBeanFactory#resolveBeanClass</code>。</p>
</blockquote>
<h4 id="准备方法重写">3.2.2. 准备方法重写</h4><p>如果Bean名称对应的<code>BeanDefinition</code>配置了方法重写，则需要校验待重写的方法是否存在，并且标记是否为重载。主要用于XML配置中<code>lookup-method</code>和<code>replace-method</code>标签及注解配置中的<code>@Lookup</code>的前置校验。</p>
<ul>
<li><code>lookup-method</code>：用于重写指定Bean的某个方法，使其返回指定的Bean，也是方法注入的实现。</li>
<li><code>replace-method</code>：用于重写指定Bean的某个方法，使其委派给指定<code>MethodReplacer</code>的<code>reimplement</code>方法。</li>
</ul>
<blockquote>
<p>对应源码所在位置：<code>AbstractBeanDefinition#prepareMethodOverrides</code>。</p>
</blockquote>
<h4 id="实例化前解析Bean">3.2.3. 实例化前解析Bean</h4><p>依次执行<code>InstantiationAwareBeanPostProcessor</code>后置处理器的<code>postProcessBeforeInstantiation</code>方法，如果返回的Bean不为空，则依次执行<code>BeanPostProcessor</code>后置处理器的<code>postProcessAfterInitialization</code>方法，如果返回的Bean不为空，则跳过后续的创建Bean实例的步骤直接返回该Bean实例。</p>
<blockquote>
<p>对应源码所在位置：<code>AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation</code>。</p>
</blockquote>
<h4 id="创建Bean实例">3.2.4. 创建Bean实例</h4><p>调用<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>方法创建Bean实例，详见下文。</p>
<blockquote>
<p>对应源码所在位置：<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>。</p>
</blockquote>
<h3 id="AbstractAutowireCapableBeanFactory-doCreateBean-详解">3.3. AbstractAutowireCapableBeanFactory#doCreateBean 详解</h3><a href="/assert/puml/8df965731f48ccbab15f98bd50173cc0be0a05f079743ab5ddf0aaeccfe51d34.svg" class="gallery-item"><img src="/assert/puml/8df965731f48ccbab15f98bd50173cc0be0a05f079743ab5ddf0aaeccfe51d34.svg"></a>


<h4 id="实例化Bean">3.3.1. 实例化Bean</h4><p>实例化Bean是通过反射的方式创建Bean的实例。有以下几个步骤：</p>
<ol>
<li>如果Bean名称对应的<code>BeanDefinition</code>配置了<code>instanceSupplier</code>属性，则使用其<code>get</code>方法实例化Bean；</li>
<li>如果Bean名称对应的<code>BeanDefinition</code>配置了<code>factoryMethodName</code>属性，则使用工厂方法实例化Bean。这也是XML配置中<code>bean</code>标签的<code>factory-method</code>和<code>factory-bean</code>属性的原理；</li>
<li>如果依次执行<code>SmartInstantiationAwareBeanPostProcessor</code>后置处理器的<code>determineCandidateConstructors</code>方法后有返回候选构造器或Bean名称对应的<code>BeanDefinition</code>中配置了构造器自动装配模式，或<code>BeanDefinition</code>中配置了构造器参数，或显式传入了参数，则使用构造器注入的方式实例化Bean；</li>
<li>如果Bean名称对应的<code>BeanDefinition</code>配置了首选构造器，则使用构造器注入的方式实例化Bean；</li>
<li>如果以上条件均不满足，则使用无参构造器实例化Bean。</li>
</ol>
<blockquote>
<p>对应源码所在位置：<code>AbstractAutowireCapableBeanFactory#createBeanInstance</code>。</p>
</blockquote>
<h4 id="合并BeanDefinition后置处理">3.3.2. 合并BeanDefinition后置处理</h4><p>依次执行<code>MergedBeanDefinitionPostProcessor</code>后置处理器的<code>postProcessMergedBeanDefinition</code>方法，对已被合并的<code>BeanDefinition</code>进行后置处理。</p>
<blockquote>
<p>对应源码所在位置：<code>AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</code>。</p>
</blockquote>
<h4 id="设置Bean的属性">3.3.3. 设置Bean的属性</h4><p>设置Bean的属性是通过反射的方式将<code>BeanDefinition</code>中配置的属性值设置到Bean的实例中去。有以下几个步骤：</p>
<ol>
<li>依次执行<code>InstantiationAwareBeanPostProcessor</code>后置处理器的<code>postProcessAfterInstantiation</code>方法，对Bean进行实例化后置处理，如果返回<code>false</code>则跳过后续步骤；</li>
<li>如果Bean名称对应的<code>BeanDefinition</code>配置了自动装配模式，则通过<code>autowireByName</code>或<code>autowireByType</code>进行自动装配，将装配好的属性设置到<code>BeanDefinition</code>中去；</li>
<li>依次执行<code>InstantiationAwareBeanPostProcessor</code>后置处理器的<code>postProcessProperties</code>方法，对属性进行后置处理，如果返回<code>null</code>则跳过后续步骤；</li>
<li>如果Bean名称对应的<code>BeanDefinition</code>配置了<code>dependencyCheck</code>依赖检查，则需要对<code>BeanDefinition</code>中的属性值进行检查；</li>
<li>如果Bean名称对应的<code>BeanDefinition</code>配置了<code>PropertyValues</code>属性值，则需要进行属性值的应用，即通过反射的方式将属性名对应的属性值设置到Bean的实例对应的属性上。</li>
</ol>
<blockquote>
<p>对应源码所在位置：<code>AbstractAutowireCapableBeanFactory#populateBean</code></p>
</blockquote>
<h4 id="初始化Bean">3.3.4. 初始化Bean</h4><p>初始化Bean是执行Bean实例的初始化方法。有以下几个步骤：</p>
<ol>
<li>如果Bean是<code>Aware</code>接口的实例，则调用<code>Aware</code>对应的<code>set</code>方法。这也是<code>BeanNameAware</code>，<code>BeanClassLoaderAware</code>和<code>BeanFactoryAware</code>的原理。</li>
<li>依次执行<code>BeanPostProcessor</code>后置处理器的<code>postProcessBeforeInitialization</code>方法，对Bean进行初始化前后置处理；</li>
<li>如果Bean是<code>InitializingBean</code>接口的实例，则调用Bean的<code>afterPropertiesSet</code>方法进行初始化；</li>
<li>如果Bean名称对应的<code>BeanDefinition</code>配置了<code>initMethodNames</code>初始化方法名称，通过反射依次调用。这也是XML配置中<code>bean</code>标签的<code>init-method</code>属性的原理；</li>
<li>依次执行<code>BeanPostProcessor</code>后置处理器的<code>postProcessAfterInitialization</code>方法，对Bean进行初始化后后置处理；</li>
<li>返回初始化后的Bean。</li>
</ol>
<blockquote>
<p>对应源码所在位置：<code>AbstractAutowireCapableBeanFactory#initializeBean</code>。</p>
</blockquote>
<h4 id="注册Bean的销毁回调">3.3.5. 注册Bean的销毁回调</h4><p>注册Bean的销毁回调是为了后续销毁Bean时执行Bean实例的销毁方法。</p>
<blockquote>
<p>对应源码所在位置：<code>AbstractAutowireCapableBeanFactory#registerDisposableBeanIfNecessary</code>。</p>
</blockquote>
<h4 id="销毁Bean">3.3.6. 销毁Bean</h4><p>销毁Bean是执行Bean实例的销毁方法。有以下几个步骤：</p>
<ol>
<li>依次执行<code>DestructionAwareBeanPostProcessor</code>后置处理器的<code>postProcessBeforeDestruction</code>方法，对Bean进行销毁前前后置处理；</li>
<li>如果Bean是<code>DisposableBean</code>接口的实例，则调用Bean的<code>destroy</code>方法进行销毁；</li>
<li>如果Bean名称对应的<code>BeanDefinition</code>配置了<code>destroyMethodNames</code>销毁方法名称，通过反射依次调用。这也是XML配置中<code>bean</code>标签的<code>destroy-method</code>属性的原理。</li>
</ol>
<blockquote>
<p>对应源码所在位置：<code>DisposableBeanAdapter#destroy</code>。</p>
</blockquote>
<h3 id="Bean的创建的流程图">3.4. Bean的创建的流程图</h3><p>回顾上面三个步骤，Bean的创建的流程图如下：</p>
<a href="/assert/puml/69bfd1ee53e6177abe0632d487bf5a8a38f9d11368a79d7a80984ca70d3c604f.svg" class="gallery-item"><img src="/assert/puml/69bfd1ee53e6177abe0632d487bf5a8a38f9d11368a79d7a80984ca70d3c604f.svg"></a>

<h2 id="实战">4. 实战</h2><h3 id="如何自定义一个线程级Bean的作用域？">4.1. 如何自定义一个线程级Bean的作用域？</h3><p>首先什么是作用域？作用域就是一个Bean生效的范围，在这个范围内根据相同的Bean名称多次获取Bean都会返回同一个Bean。</p>
<ul>
<li>如<code>singleton</code>作用域的Bean在IoC容器中生效。</li>
<li>如<code>prototype</code>作用域的Bean在每次获取Bean中生效。</li>
<li>如<code>request</code>作用域的Bean在每次请求中生效。</li>
<li>如<code>session</code>作用域的Bean在每次会话中生效。</li>
<li>如<code>thread</code>作用域的Bean在每个线程中生效。</li>
</ul>
<p>为了自定义一个线程级Bean的作用域，需要我们提供一个线程私有的Bean的缓存用来缓存当前作用域已经被创建的Bean，不难想到可以使用<code>ThreadLocal</code>，如下代码。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
public class ThreadScopeTest &#123;

    &#x2F;**
     * 一个简单的Java Bean
     *&#x2F;
    private static class TestBean &#123;

    &#125;

    &#x2F;**
     * 自定义线程级作用域
     *&#x2F;
    public static class ThreadScope implements Scope &#123;

        &#x2F;**
         * 线程级缓存，每个线程都有一个私有的缓存
         *&#x2F;
        private static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; beanMapLocal &#x3D; ThreadLocal.withInitial(HashMap::new);

        @Override
        public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) &#123;
            &#x2F;&#x2F; 获取当前线程的缓存
            final Map&lt;String, Object&gt; beanMap &#x3D; beanMapLocal.get();
            &#x2F;&#x2F; 从缓存中获取Bean
            Object bean &#x3D; beanMap.get(name);
            if (bean &#x3D;&#x3D; null) &#123;
                &#x2F;&#x2F; 缓存中未获取到Bean，使用工厂创建Bean
                bean &#x3D; objectFactory.getObject();
                &#x2F;&#x2F; 将创建的Bean加入到缓存中
                beanMap.put(name, bean);
            &#125;
            return bean;
        &#125;

        @Override
        public Object remove(String name) &#123;
            final Map&lt;String, Object&gt; beanMap &#x3D; beanMapLocal.get();
            return beanMap.remove(name);
        &#125;

        @Override
        public void registerDestructionCallback(String name, Runnable callback) &#123;

        &#125;

        @Override
        public Object resolveContextualObject(String key) &#123;
            return null;
        &#125;

        @Override
        public String getConversationId() &#123;
            return Thread.currentThread().getName();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        DefaultListableBeanFactory beanFactory &#x3D; new DefaultListableBeanFactory();
        &#x2F;&#x2F; 注册自定义线程级别作用域
        beanFactory.registerScope(&quot;thread&quot;, new ThreadScope());
        &#x2F;&#x2F; 注册一个作用域为线程级别的 BeanDefinition
        beanFactory.registerBeanDefinition(&quot;testBean&quot;, BeanDefinitionBuilder
                .genericBeanDefinition(TestBean.class)
                .setScope(&quot;thread&quot;)
                .getBeanDefinition());

        executeInNewThread(() -&gt; &#123;
            log.info(&quot;&#123;&#125; get bean fist: &#123;&#125;&quot;, Thread.currentThread().getName(), beanFactory.getBean(TestBean.class));
            log.info(&quot;&#123;&#125; get bean second: &#123;&#125;&quot;, Thread.currentThread().getName(), beanFactory.getBean(TestBean.class));
            &#x2F;&#x2F; 销毁作用域缓存里的Bean
            beanFactory.destroyScopedBean(&quot;testBean&quot;);
        &#125;);
        executeInNewThread(() -&gt; &#123;
            log.info(&quot;&#123;&#125; get bean fist: &#123;&#125;&quot;, Thread.currentThread().getName(), beanFactory.getBean(TestBean.class));
            log.info(&quot;&#123;&#125; get bean second: &#123;&#125;&quot;, Thread.currentThread().getName(), beanFactory.getBean(TestBean.class));
            &#x2F;&#x2F; 销毁作用域缓存里的Bean
            beanFactory.destroyScopedBean(&quot;testBean&quot;);
        &#125;);
    &#125;

    private static void executeInNewThread(Runnable runnable) &#123;
        new Thread(runnable).start();
    &#125;
&#125;</code></pre>
<p>运行结果如下图。线程级作用域的Bean是在每个线程中生效，体现在行为上是：</p>
<ol>
<li>相同的线程之间的Bean是共享的，也意味着在根据相同的Bean名称在相同的线程执行<code>getBean</code>方法，会返回相同的Bean；</li>
<li>不同的线程之间的Bean不是共享的，也意味着根据相同的Bean名称在不同的线程执行<code>getBean</code>方法，会返回不同的Bean。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">Thread-1 get bean fist: com.remeio.upsnippet.spring.beanfactory.ThreadScopeTest$TestBean@5e98cb5f
Thread-0 get bean fist: com.remeio.upsnippet.spring.beanfactory.ThreadScopeTest$TestBean@49e16fa6
Thread-1 get bean second: com.remeio.upsnippet.spring.beanfactory.ThreadScopeTest$TestBean@5e98cb5f
Thread-0 get bean second: com.remeio.upsnippet.spring.beanfactory.ThreadScopeTest$TestBean@49e16fa6</code></pre>

<h3 id="如何解决原型Bean依赖注入单例Bean导致原型失效的问题？">4.2. 如何解决原型Bean依赖注入单例Bean导致原型失效的问题？</h3><p>当使用<code>@Autowired</code>将一个原型Bean依赖注入到一个单例Bean中时，该单例Bean每次获取该原型Bean都会得到同一个Bean，这和我们使用原型Bean的初衷相违背；原因是依赖注入仅会发生一次，后续都将使用被依赖注入的Bean。如何解决这个问题呢？核心思路在于每次获取原型Bean的时候都需要触发<code>getBean</code>方法，使其触发作用域创建Bean的方法，有以下几种方式：</p>
<ul>
<li>使用依赖查找<code>BeanFactory#getBean</code>代替依赖注入<code>@Autowired</code>；</li>
<li>使用方法覆盖<code>@Lookup</code>去代理获取原型Bean的方法。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j
public class LookupTest &#123;


    @Component
    @Scope(BeanDefinition.SCOPE_SINGLETON)
    public static class SingletonTestBean &#123;

        @Autowired
        private PrototypeTestBean prototypeTestBean;

        @Autowired
        private BeanFactory beanFactory;

        public PrototypeTestBean getPrototypeTestBeanByAutowired() &#123;
            return prototypeTestBean;
        &#125;

        @Lookup(&quot;prototypeTestBean&quot;)
        public PrototypeTestBean getPrototypeTestBeanByLookup() &#123;
            return null;
        &#125;

        public PrototypeTestBean getPrototypeTestBeanByGetBean() &#123;
            return beanFactory.getBean(PrototypeTestBean.class);
        &#125;

    &#125;

    @Component(&quot;prototypeTestBean&quot;)
    @Scope(BeanDefinition.SCOPE_PROTOTYPE)
    public static class PrototypeTestBean &#123;

    &#125;

    public static void main(String[] args) &#123;
        AnnotationConfigApplicationContext context &#x3D; new AnnotationConfigApplicationContext();
        context.register(SingletonTestBean.class, PrototypeTestBean.class);
        context.refresh();

        SingletonTestBean singletonTestBean &#x3D; context.getBean(SingletonTestBean.class);
        printInfo(&quot;@Autowired&quot;, singletonTestBean::getPrototypeTestBeanByAutowired);
        printInfo(&quot;BeanFactory#getBean&quot;, singletonTestBean::getPrototypeTestBeanByGetBean);
        printInfo(&quot;@Lookup&quot;, singletonTestBean::getPrototypeTestBeanByLookup);
    &#125;

    private static void printInfo(String message, Supplier&lt;PrototypeTestBean&gt; supplier) &#123;
        PrototypeTestBean first &#x3D; supplier.get();
        PrototypeTestBean second &#x3D; supplier.get();
        log.info(&quot;Get prototype test bean by &#123;&#125;: &#123;&#125; &#x3D;&#x3D; &#123;&#125;? &#123;&#125;&quot;,
                message,
                first,
                second,
                first &#x3D;&#x3D; second);
    &#125;

&#125;</code></pre>
<p>运行结果如下图。可以看到使用依赖查找<code>BeanFactory#getBean</code>和方法覆盖<code>@Lookup</code>的方式每次获取原型Bean都会返回不同的Bean。</p>
<pre class="line-numbers language-none"><code class="language-none">Get prototype test bean by @Autowired: com.remeio.upsnippet.spring.beanfactory.LookupTest$PrototypeTestBean@6973bf95 &#x3D;&#x3D; com.remeio.upsnippet.spring.beanfactory.LookupTest$PrototypeTestBean@6973bf95? true
Get prototype test bean by BeanFactory#getBean: com.remeio.upsnippet.spring.beanfactory.LookupTest$PrototypeTestBean@229d10bd &#x3D;&#x3D; com.remeio.upsnippet.spring.beanfactory.LookupTest$PrototypeTestBean@47542153? false
Get prototype test bean by @Lookup: com.remeio.upsnippet.spring.beanfactory.LookupTest$PrototypeTestBean@7a4ccb53 &#x3D;&#x3D; com.remeio.upsnippet.spring.beanfactory.LookupTest$PrototypeTestBean@309e345f? false</code></pre>

<h3 id="三级缓存是如何解决循环依赖的？">4.3. 三级缓存是如何解决循环依赖的？</h3><p>学习中，后续更新。</p>
</div><script src></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
</div>
  <hr/>
  <div class="article-footer">
    <a href="/post/3238870166/">上一篇：Bean在Spring中是如何被加载的？</a>
    <a href="/post/2756090231/">下一篇：Bean在Spring中是如何完成依赖注入的？</a>
  </div>
  <div class="toc-pin">
  <h4>目录</h4>
  <hr>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">1. 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">2. 如果让你设计，你会如何设计？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">3. Spring是如何设计的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractBeanFactory-doGetBean-%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.1. AbstractBeanFactory#doGetBean 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%BC%A0%E5%85%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-text">3.1.1. 转换传入的名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8D%95%E4%BE%8B%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96Bean"><span class="toc-text">3.1.2. 从单例缓存中获取Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%88%B6BeanFactory%E4%B8%AD%E8%8E%B7%E5%8F%96Bean"><span class="toc-text">3.1.3. 从父BeanFactory中获取Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6BeanDefinition"><span class="toc-text">3.1.4. 合并BeanDefinition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="toc-text">3.1.5. 检查依赖项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9D%A5%E5%88%9B%E5%BB%BABean"><span class="toc-text">3.1.6. 根据作用域来创建Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8EBean%E5%AE%9E%E4%BE%8B%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.1.7. 从Bean实例中获取对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8DBean%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1.8. 适配Bean实例的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractAutowireCapableBeanFactory-createBean-%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.2. AbstractAutowireCapableBeanFactory#createBean 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90Bean%E7%9A%84Class"><span class="toc-text">3.2.1. 解析Bean的Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">3.2.2. 准备方法重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%89%8D%E8%A7%A3%E6%9E%90Bean"><span class="toc-text">3.2.3. 实例化前解析Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABean%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.2.4. 创建Bean实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractAutowireCapableBeanFactory-doCreateBean-%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.3. AbstractAutowireCapableBeanFactory#doCreateBean 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96Bean"><span class="toc-text">3.3.1. 实例化Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6BeanDefinition%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-text">3.3.2. 合并BeanDefinition后置处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEBean%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">3.3.3. 设置Bean的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96Bean"><span class="toc-text">3.3.4. 初始化Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CBean%E7%9A%84%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"><span class="toc-text">3.3.5. 注册Bean的销毁回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81Bean"><span class="toc-text">3.3.6. 销毁Bean</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">3.4. Bean的创建的流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-text">4. 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BA%A7Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">4.1. 如何自定义一个线程级Bean的作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%9E%8BBean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8D%95%E4%BE%8BBean%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%9E%8B%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">4.2. 如何解决原型Bean依赖注入单例Bean导致原型失效的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="toc-text">4.3. 三级缓存是如何解决循环依赖的？</span></a></li></ol></li></ol>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      var navLinks = document.querySelectorAll('.toc-pin a');
      if (!navLinks) {
        return
      }
      var sectionIds = []
      navLinks.forEach(function(link) {
        sectionIds.push(decodeURIComponent(link.hash).substring(1))
      });
      window.addEventListener('scroll', function() {
        var currentPosition = window.scrollY || window.pageYOffset;
        sectionIds.forEach(function(id) {
          var section = document.querySelector('#' + id);
          var navLink = document.querySelector('.toc-pin a[href="#' + encodeURIComponent(id) + '"]');
          if (section && currentPosition >= (section.offsetTop - 60)) {
            navLinks.forEach(function(link) {
              link.classList.remove('highlight');
            });
            navLink.classList.add('highlight');
            if (navLinks[0] === navLink) {
              document.querySelector('.toc-pin h4').scrollIntoView();
            } else {
              navLink.scrollIntoView()
            }
          }
        });
      });
    });
  </script>
</div>
  <img class="article-to-toc" title="打开目录" onclick="openOrCloseTocPin()" src="/img/maximize.svg"/>
  <script>
    function showToc(show) {
      localStorage.setItem('tocPinState', show ? '1' : '0')
      var tocPin = document.querySelectorAll('.toc-pin')[0];
      tocPin.style.display = show ? '' : 'none'
      var mainPost = document.querySelectorAll('.main-post')[0];
      mainPost.style.marginLeft = show ? '' : 'auto'
      mainPost.style.width = show ? '' : '70%'
      var articleToTocButton = document.querySelectorAll('.article-to-toc')[0];
      articleToTocButton.src = show ? '/img/maximize.svg' : '/img/minimize.svg'
      articleToTocButton.title = show ? '关闭目录' : '打开目录'
    }
    function openOrCloseTocPin() {
      const show = localStorage.getItem('tocPinState') === '0'
      showToc(show)
    }
    showToc(localStorage.getItem('tocPinState') != '0')
  </script>
</main>
    <footer>
  <div class="footer-info">
  <a>© 2024 徐梦旗</a> 
  | <a target="_blank" rel="noopener" href="https://github.com/mizoreyo/hexo-theme-insnow">Theme Insnow</a>
  | <a href="/console">控制台</a>
  | <a href="http://beian.miit.gov.cn/"; target=_blank>浙ICP备2021010658号-1</a>
  | <img src="/img/ghs.png" style="width:12px;margin: 0 0.4rem 0 0.4rem;"/><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33011802002272">浙公网安备 33011802002272号</a>
  | <a class="footer-i" href="" title="@remeio"><i class="iconfont icon-wechat"></i></a>
  <a class="footer-i" target="_blank" rel="noopener" href="https://github.com/remeio"><i class="iconfont icon-github-fill"></i></a>
  <a class="footer-i" href="mailto:2663479778@qq.com"><i class="iconfont icon-mail"></i></a>
</div>
</footer>
  </div>
<script src="/js/markmap.js"></script></body>
</html>